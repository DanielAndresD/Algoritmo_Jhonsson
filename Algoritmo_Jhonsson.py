# -*- coding: utf-8 -*-
"""Problema 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qAcu0UrhilqM-rqoK3vqe4_3mtdn_jtb

# Problema No. 2
Suponga que cuenta con 30 trabajos que deben ser secuenciados en tres diferentes máquinas siguiendo la misma ruta M1-M2- M3, los tiempos de procesamiento se dan en la Tabla 2.
"""

#Código para cargar la información de entrada
import numpy as np

tabla2= np.loadtxt('DP2.txt',int)

print("Tarea"," M1","M2"," M3")
print(tabla2)

"""Codifique un algoritmo en algún lenguaje de programación (vba, java, c + +, gams, matlab...), que le permita aplicar la adaptación del algoritmo de Johnson para el caso de tres máquinas, recuerde que el algoritmo debe permitir utilizar cualquier tamaño de instancia.

# **Desarrollo**

Una vez se carga la información de entrada, se verifican las condiciones de optimalidad del Algoritmo de Johnson.
"""

P1= min(tabla2[:,1]) #Mínimo tiempo de procesameinto M1
P2= max(tabla2[:,2]) #Máximo tiempo de procesameinto M2
P3= min(tabla2[:,3]) #Mínimo tiempo de procesameinto M3
print(
"Mínimo tiempo de procesamiento M1: "+str(P1) 
+"\n"+
"Máximo tiempo de procesamiento M2: "+str(P2) 
+"\n"+
"Mínimo tiempo de procesamiento M3: "+str(P3)    
)

"""Condiciones para garantizar la optimalidad:
1. Min(Pj-M1)>= Máx(Pj-M2)
2. Min(Pj-M3)>=Máx(Pj-M2)
"""


if  (P1>=P2) or (P3>=P2):
  print("Se cumple al menos una condición por lo tanto el AJ es óptimo")
else:
  print("No se cumple ninguna de las dos condiciones, por lo que el AJ no garantiza optimalidad")

"""Se aplica el algoritmo de Johnson para determinar la secuenciación.
Pseudocodígo:

**1° Paso Matriz temporal para aplicar la secuenciación**


```
m(n,3) #donde n corresponde al número de trabajos a procesar
    -En la primer columna se asigna el indicativo de la tarea
    -En la segunda columna los tiempos de procesamiento de la primer máquina
    -En la tercer columna los tiempos de procesamiento de la tercer máquina

Sec(n) #Vector que almacena la secuenciación final
```
**2° Paso Adaptar el problema de 3 Máquinas a 2 Máquinas**

```
  For i=1 -> n
    m[i,1]= M1(i)+M2(i)
    m[i,2]= M2(i)+M3(i)
```
**3° Paso: Definir la función de búsqueda para el indicativo de la tarea**


```
Busqueda(Tarea a buscar [x],Matriz de búsqueda [M],Indicativo de la máquina a realizar búsqueda [j])
  k1=0 #contador
  While x diferente m[k1,j[
    k1=k1+1
  Retornar (k1)# se devuelve la posición de la tarea a asignar
```
**4° Paso: Aplicar la regla de Johnson**


```
k=0 #contador de las tareas a asignar en orden ascendente
l=n #contador de las tareas a asignar en orden descendente
Mientras k <= n #Critero para la detención del algortimo
  k=k+1
  l=l+1
    #buscar los tiempos mínimos de las actividades por programar en la matriz temporal
  n1=MinP(m(M1))
  n2=MinP(m(M2))
    #Condicional para identificar la máquina con mínimo tiempo de procesamiento en la actividad
  If n1 >= n2
    x=n1
    j=1
  else
    x=n2
    j=n2
    #Aplicar la función de búsqueda
  mm=buscar(x,m,j) #tarea a secuenciar
    #Aplicar la regla de secuenciación 
  If j=1 
    sec[i+1] = mm # se organiza en orden ascendente
  else if j=2
    sec[i-1]=mm # se organiza de forma descendente
  #eliminar la tarea que ya fue asignada de la matriz temporal
  delete(m(mm))
  
```
Repetir el paso 4 hasta que todas las tareas sean asignadas

**Implementación del código para resolver el problema de secuenciación en 2 máquinas mediante el algortimo de Johnson**
"""

k=0
l=len(tabla2) 
m=tabla2[:,(0,0,0)] # matriz temporal para organizar la secuencia
#Ajuste del problema de 3 máquinas a 2 máquinas
for i in range(0,l):
  m[i,1]=tabla2[i,1]+tabla2[i,2]
  m[i,2]=tabla2[i,2]+tabla2[i,3]

sec=[None]*len(tabla2) #vector que almacena la secuencia
#Función buscar para encontrar el indicativo de la tarea
def buscar(x,m,j):
  k1=0
  while x != m[k1,j]:
     k1 +=1
  buscar=k1
  return buscar
#Algoritmo de Johnson
while k <=len(tabla2)-1:
  k +=1
  l -=1
  n1=min(m[:,1])
  n2=min(m[:,2])
 # condición de evaluación del valor mínimo según la máquina
  if n1 <=n2:
    x=n1
    j=1
  else:
    x=n2
    j=2
  mm=buscar(x,m,j)
  if j==1:
    i=0
    while sec[i] != None:
      i +=1
    sec[i]=m[mm,0]
  else:
    i=len(sec)-1
    while sec[i] != None:
      i -=1
    sec[i]=m[mm,0]
  m= np.delete(m,mm,0) 
print(sec)

"""Una vez obtenida la secuencia, se calculan las medidas de desempeño"""